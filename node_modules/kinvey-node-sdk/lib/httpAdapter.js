Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var axios_1 = tslib_1.__importDefault(require("axios"));
var os_1 = tslib_1.__importDefault(require("os"));
var network_1 = require("kinvey-js-sdk/lib/errors/network");
var timeout_1 = require("kinvey-js-sdk/lib/errors/timeout");
var package_json_1 = require("../package.json");
function deviceInformation() {
    var platform = process.title;
    var version = process.version;
    var manufacturer = process.platform;
    // Return the device information string.
    var parts = ["js-" + package_json_1.name + "/" + version];
    return parts.concat([platform, version, manufacturer]).map(function (part) {
        if (part) {
            return part.toString().replace(/\s/g, '_').toLowerCase();
        }
        return 'unknown';
    }).join(' ');
}
function deviceInfo() {
    return {
        hv: 1,
        os: os_1.default.platform(),
        ov: os_1.default.release(),
        sdk: {
            name: package_json_1.name,
            version: package_json_1.version
        },
        pv: process.version
    };
}
exports.deviceInfo = deviceInfo;
function send(request) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var url, method, headers, body, timeout, response, error_1;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    url = request.url, method = request.method, headers = request.headers, body = request.body, timeout = request.timeout;
                    // Add kinvey device information headers
                    if (/kinvey\.com/gm.test(url)) {
                        headers['X-Kinvey-Device-Information'] = deviceInformation();
                        headers['X-Kinvey-Device-Info'] = JSON.stringify(deviceInfo());
                    }
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, axios_1.default({
                            headers: headers,
                            method: method,
                            url: url,
                            data: body,
                            timeout: timeout
                        })];
                case 2:
                    response = _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    error_1 = _a.sent();
                    if (error_1.code === 'ESOCKETTIMEDOUT'
                        || error_1.code === 'ETIMEDOUT'
                        || error_1.code === 'ECONNABORTED') {
                        throw new timeout_1.TimeoutError('The network request timed out.');
                    }
                    if (error_1.code === 'ENOENT'
                        || !error_1.response) {
                        throw new network_1.NetworkError();
                    }
                    response = error_1.response;
                    return [3 /*break*/, 4];
                case 4: return [2 /*return*/, {
                        statusCode: response.status,
                        headers: response.headers,
                        data: response.data
                    }];
            }
        });
    });
}
exports.send = send;
//# sourceMappingURL=httpAdapter.js.map